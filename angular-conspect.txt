+ angular - framework for creating reactive SPA-application.

+ creating project: npm install -> ng new [app-name] -> cd [app-name] -> ng serve /*for start*/

+ typescript - superset of javascript that has a lot of features and are compiling by CLI /* A command line interface for Angular */.

+ app start: at main.ts we declare main module /* => platformBrowserDynamic().bootstrapModule(AppModule) */
  - it's meant that AppModule is main module of our app. At main module (AppModule) we declare main component
  at bootstap property /* bootstrap: [AppComponent] */. And finaly we declare at index.html css-tag with our 
  main component's template;

+ components - a key feature at Angular. The Angular app is a complex of components.

+ main component: there are basic component - all others components existing at this component.

+ creating component: component is a typescript class with @component decorator imported from '@Angular/core'.
  for using component we have to declare our component at main module's declarations field.
  
+ component's ts file - business logic of component (+template, styles, etc..).

+ component's template: it's html page, that user can see; internal -> template: `<html>....` ; external -> templateUrl : './comp..html';

+ component's style: internal or external styles...

+ component's selector - it can be like css-selector: 'app-component' or like property '[app-component]' or like css-class '.app-component';

+ databinding - communication between data from our bussiness logic and vour view.
  + one way databinding:
    + string interpolation -> {{ field }} - from BL to view
    + property binding -> [property]='field' - from BL to view
    + event binding (event) = ' expression' - from view to BL
  + two-way databinding:
    + using of ngModel directive [(ngModel)]='data'

+ directives: are instructions in DOM; ts class with @Directive decorator
  + structural  - add or remove elements in DOM ( *ngIf, *ngFor, [ngSwtich] )
  + attribute  - change elements where they are ( ngStyle, ngClass )
  
+ we can't have more than one structural directiove on the one element.
  
+*ngIf: add or remove element at DOM if *ngIF='true'

+ ngFor: add a list of ?fields? at DOM -> <div *ngFor="let item of items"; let i = index" >, where item - each field of list of items, i - index from 0.

+ @Input(' outsideName' ) decorator from '@Angular/core': (binding component's properties beetween 2 components)  all component's properties by default are available only inside of this component.
   If you need to use some properties from children component in parent component you have to use @Input decorator to make available field you are needed.
   outsideName - name for children's property for using this property outside like (wos 'element' -> serverElement). It looks like @Input('serverElement') element: string; 

+ For creating your own attribute directive, you have to:
   1) creacte .ts file with class.   
   2)this class has to be with @Directive decorator (from '@Angular/core').  
   3)you have to use elRef: ElementRef at constructor - for getting access to the element.  
   4) at onInit you can do somethink like ->  this.elRef.nativeElement.style.backgroundColor = 'green'.
   5) you have to inform AppModule about using this directive at declarations array.
   
   !!! better way:
    1) creacte .ts file with class.   
   2)this class has to be with @Directive decorator (from '@Angular/core').  
   3)you have to use elRef: ElementRef at constructor - for getting access to the element and renderer: Renderer2 ( you should use the Renderer for any DOM manipulations )
   4) at onInit you can do somethink like -> this.elRef.renderer.setStyle( this.elRef.nativeElement, 'background-color', 'blue')
   5) you have to inform AppModule about using this directive at declarations array.

+ @HostListener decorator is allow to bind DOM event with directive's methods like ->
   @HostListener("mouseenter") onMouseEnter() { this.elRef.renderer.setStyle( this.elRef.nativeElement, 'background-color', 'blue'); }
                              DOM event       method of directive

+ @HostBinding decorator for binding class property with directive's element's property 

+  use HostBinding with HostListener and @Input decorator for creating dinamic directives.	
	host: {
 	   '(mouseenter)': 'onMouseEnter()',
	    '(mouseleave)': 'onMouseLeave()'
	}


+ EventEmitter<someObject>() - object that allow you emitt your own event;

+ @Output(' ') decorator from '@angular/core' - listning your own events ...

+ View encapsulation: each component has own css style through adding the own attribute to each own css-tag at DOM).

+ Local references ( like <input #ref ...> ) - hold reference to html tah with all properties. You can use it only inside template , not at stypescript code.
   If ref to input element - you can get the value of input of input -> ref.value.

+ @ViewChild('ref') field: ElementRef. -> this.field.nativeElement.value.

+ <ng-content></ng-content> directive at component template. 
   All code taht are beetween opening and clothing selector of this component ( <app-component>...|...</app-component> )moving to the <ng-content></>.

+ The component Lifecicle: 
	+ ngOnChanges - called when component is creating and each time when the component's input is changing
	+ ngOnInit - called once when the component is initializined ( AFTER CONSTRUCTOR ).
	+ ngDoCheck - called during every change detection run (any changes at template).
	+ ngAfterContentInit - called every time the project's content has been checked.
	+ ngAfterViewInit
	+ngAfterViewChecked
	+ngOnDestroy.

+ @ContentChild('name' paragraph: RefElementKey -> access to ng-content;

+ Services - Dependencies are singletons within the scope of an injector. use for 'D.R.Y'. It's a simple ts class ( name.service.ts ).
   for using that you have to import and add service to the providers array of  the component, where you will use this service.

+ We use Service :
	+when we working with data, 
	+when we have some business-logic and it's logic dosn't touch the templates, 
	+for logging, 
	+when we need some communication between components

+  Hierarchical Injector:
	+AppModule - Same instance of Service is available Application-wide
	+AppComponent - same instance of service is available for all Components ( but not for other services)
	+Any other component - same instance of Service is available for component and all its child component  
   --> if you want to create one instance of a Service -> add it to the highest level componet (import it and add to the providers array), [ add it to the appModule (import it and add to the providers array) ]
        BUT at childs components ONLY import that service and add to the constructors, BUT DON'T add it to the providers array 

+ Injecting one service into another: you have to add the first service to the providers array of the appModule, then import and "create" instance of first service at constructor of second service,
   then you have to use @Injectable decorator from '@Angular/core' for second service 
	(looks like -> @Injectable() 
		export class secondService{ 
		constructor ( fService: FirstService ){} 
				}

+ decorators ( like @Component, @Directive, @Injectable) - metadata for app ...